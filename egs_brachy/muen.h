/*
################################################################################
#
#  egs_brachy muen.h
#  Copyright (C) 2016 Rowan Thomson, Dave Rogers, Randle Taylor, and Marc
#  Chamberland
#
#  This file is part of egs_brachy
#
#  egs_brachy is free software: you can redistribute it and/or modify it
#  under the terms of the GNU Affero General Public License as published
#  by the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  egs_brachy is distributed in the hope that it will be useful, but
#  WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
#  Affero General Public License for more details:
#  <http://www.gnu.org/licenses/>.
#
################################################################################
#
#  When egs_brachy is used for publications, please cite our paper:
#  M. J. P. Chamberland, R. E. P. Taylor, D. W. O. Rogers, and R. M. Thomson,
#  egs brachy: a versatile and fast Monte Carlo code for brachytherapy,
#  Phys. Med. Biol. 61, 8214-8231 (2016).
#
################################################################################
#
#  Author:        Randle Taylor, 2016
#
#  Contributors:  Marc Chamberland
#                 Dave Rogers
#                 Rowan Thomson
#
################################################################################
*/

/*! \file muen.h
 * \author Randle Taylor (randle.taylor@gmail.com)
 * \brief Functions for loading muen data from a file.
 *
 */
#include <algorithm>
#include <fstream>
#include <string>
#include <istream>
#include <iostream>
#include <sstream>
#include <map>
#include <cstdlib>
#include <vector>

#include "egs_functions.h"
#include "egs_input.h"
#include "egs_interpolator.h"


#ifndef MUENDATA_
#define MUENDATA_

namespace muen {

using namespace std;


/*! \brief Split a string on input delimeter */
std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) {
    std::stringstream ss(s);
    std::string item;
    while (std::getline(ss, item, delim)) {
        elems.push_back(item);
    }
    return elems;
}


/*! \brief Split a string on input delimeter */
std::vector<std::string> split(const std::string &s, char delim) {
    std::vector<std::string> elems;
    split(s, delim, elems);
    return elems;
}

/*! \brief trim whitespace from start of string */
static inline std::string &ltrim(std::string &s) {
    s.erase(s.begin(), std::find_if(s.begin(), s.end(), [](unsigned char ch) {return !std::isspace(ch);}));
    return s;
}

/*! \brief trim whitespace from end of string */
static inline std::string &rtrim(std::string &s) {
    s.erase(std::find_if(s.rbegin(), s.rend(), [](unsigned char ch) {return !std::isspace(ch);}).base(), s.end());
    return s;
}

/*! \brief trim whitespace from both ends of string */
static inline std::string &trim(std::string &s) {
    return ltrim(rtrim(s));
}


/*! \brief pair of form (energy, muen(energy)) */
typedef pair<double, double> MuenAtET;

/*! \brief Map from medium name to vector of (e, muen(e)) data for that medium */
typedef map<string, vector<MuenAtET> > MuenMapT;

/*! \brief class for parsing muen data from a file.
 *
 * The muen data must be in the format generated by
 * the egsnrc usercode `g`:\verbatim

    Muen values for medium MEDIUM = MED_NAME_1
    Medium used is MED_NAME_1 found in your_pegs_data_set
    Number of energy intervals is 2000
    Energy       Muen
    0.001000 MeV 4075.692785 cm^2/g
    0.001004 MeV 4036.185761 cm^2/g
    0.001007 MeV 3997.307705 cm^2/g
    (# 1997 more lines)
    Muen values for medium MEDIUM = MED_NAME_2
    Medium used is MED_NAME_2 found in your_pegs_data_set
    Number of energy intervals is 500
    0.001000 MeV 4075.692785 cm^2/g
    0.001004 MeV 4036.185761 cm^2/g
    0.001007 MeV 3997.307705 cm^2/g
    (# 497 more lines)
 \endverbatim
 */
class MuenDataParser {

    MuenMapT med_data; /*!< holds all muen data from file. */

    static const int NSKIP = 3; /*!< number of lines in muen data for
                                  a medium to skip between first line for
                                  a medium and the start of the data*/


    /*! \brief does the actual parsing of data from the muen file*/
    MuenMapT splitFileByMed(ifstream &in) {

        MuenMapT med_lines;

        string cur_med_name, dummy;

        while (in) {

            string line;
            getline(in, line);
            if (trim(line).size() == 0) {
                continue;
            }

            bool new_med = line.find(MUEN_START) != string::npos;

            if (new_med) {
                /* new medium found. Update the current medium name
                 * and move file pointer to start of data */
                cur_med_name = trim(split(line, '=')[1]);
                for (int i=0; i < NSKIP; i++) {
                    getline(in, dummy);
                    if (trim(dummy).size() == 0) {
                        i--;
                    }
                }
            } else {

                istringstream iss(line);

                double energy, muen;
                iss >> energy;
                iss >> dummy; // skip the MeV unit
                iss >> muen;

                if (iss.fail() && in) {
                    egsWarning("MuenDataParser:: Invalid muen data file format. Last line was:\n%s\n ", line.c_str());
                    med_lines.clear();
                    return med_lines;
                } else {
                    med_lines[cur_med_name].push_back(MuenAtET(energy, muen));
                }
            }
        }

        return med_lines;

    }


public:

    static const string MUEN_START; /*!< string indicating start of a new medium */

    /*! \brief construct class by parsing the data file.  Note the actual
     * EGS_Interpolator classes are only created when user calls
     * getMuenInterpolator.  User is responsible for deleting the interpolator
     * when they are done with it.
     *
     * \note Rather than just calling egsFatal on failure we should probably
     * set a `success` flag and then let the users check the flag and decide
     * what they want to do.
     *
     * */
    MuenDataParser() {};

    int setMuenFile(string filename) {

        ifstream muen_data(filename.c_str());

        if (!muen_data) {
            return 1;
        }

        med_data = splitFileByMed(muen_data);
        muen_data.close();
        return 0;

    };

    /*! \brief Create a new EGS_Interpolator of muen data for the requested medium
     * and return pointer to it. Ownership of the object belongs to the caller.
     *
     * \note currently calling repeatedly with the same med_name will create a new
     * instance of EGS_Interpolator for every call.  We could change this to return
     * a cached copy if it had already been created in the past.
     * */
    EGS_Interpolator *getMuenInterpolator(string med_name) {

        size_t ndat = med_data[med_name].size();
        if (ndat < 2) {
            return 0;
        }
        EGS_Float emin = med_data[med_name][0].first;
        EGS_Float emax= med_data[med_name][ndat-1].first;

        EGS_Float *fmuen = new EGS_Float[ndat];
        for (size_t i=0; i < ndat; i++) {
            fmuen[i] = med_data[med_name][i].second;
        }

        EGS_Interpolator *muen = new EGS_Interpolator(ndat, log(emin), log(emax), fmuen);
        delete [] fmuen;

        return  muen;

    }
};


const string MuenDataParser::MUEN_START = "Muen values for medium MEDIUM =";

}

#endif
